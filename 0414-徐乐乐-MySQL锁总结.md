# MySQL锁总结

相关详细概述：[](https://dev.mysql.com/doc/search/?q=lock)

#### 概述

锁是**计算机协调多个进程或线程并发访问某一资源的机制**。锁保证数据并发访问的一致性、有效性；锁冲突也是影响数据库并发访问性能的一个重要因素。锁是Mysql在**服务器层**和**存储引擎层**的的并发控制。

**加锁是消耗资源的**，锁的各种操作，包括获得锁、检测锁是否是否已解除、释放锁等。

我们举一个例子，淘宝购物。 假设我们到购物网站上购买一个商品，这个时候库存为数不多，多个人一起抢购，那么如何解决是你买到还是别人买到的问题？

这个时候，就需要用锁，**对有限的资源进行保护，解决并发的矛盾。**

#### 锁的分类

从对数据操作的颗粒度来看，锁可以分为表锁和行锁。

**表锁**：操作数据的时候，**锁住整张表**。（是**MyISAM存储引擎**有的锁，**开销小，加锁快，无死锁，锁的粒度大，发生锁冲突的概率最高，并发量最低。**）

**行锁**：操作数据的时候，**锁住需要操作的那一行数据。**（是偏向Innodb的存储引擎，**开销大，加锁慢，会出现死锁，锁定粒度最小，发生锁冲突的概率极低，并发度也最高**）



从数据操作的类型来看，锁可以分为**读锁和写锁**：

**读锁**（共享锁）：针对读操作，多个读操作可以同时进行而不互相影响，但是不能进行写操作。

**写锁**（排它锁）：当前操作没有完成前，它会阻断其他写锁和读锁。

**表锁演示**：				加读锁：

|                         session1                          |                  session2                   |
| :-------------------------------------------------------: | :-----------------------------------------: |
| 加读锁，lock  table   t_error_name   read     OK,时间：0s |                  连接mysql                  |
|               当前session可以查询该表的记录               |      其他的session也可以读取该表的记录      |
|            当前session不可以查询没有read锁的表            |    其他session可以查询或者更新未锁定的表    |
|          当前session不可以插入或者更新read锁的表          | 其他session插入或者更新read锁住的表表会阻塞 |
|                    unlock  table释放锁                    |         其他session插入或者更新完成         |

加写锁

|                     session1                      |           session2            |
| :-----------------------------------------------: | :---------------------------: |
|                 当前session加写锁                 |     等待session1加锁完毕      |
| 当前session的查询，增加，修改，删除都可以执行完成 | 对其它session，任何操作都锁定 |
|                    lock释放锁                     |  session2可以对该表进行操作   |

结论：
1.对MyISAM表的读操作（加读锁），**不会阻塞其他进程对同一表的读请求**，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行对其它进程的写操作。
2.对MyISAM表的写操作（加写锁），**会阻塞其它进程对同一表的读和写操作**，只有当写操作释放后，才会执行其它进程的读写操作。

总而言之，**读会阻塞写，不会阻塞读，写会同时阻塞读写。**

所以我们可以得出，**MyISAM存储引擎的读写锁调度是写优先，**也就是MyISAM**不适合做主表的引擎**，因为一张表加上写锁后，会极大降低吞吐量，大量的请求将会被阻塞。

**行锁演示**：

|             session1              |             session2              |
| :-------------------------------: | :-------------------------------: |
| 设置手动提交事务set  autocommit=0 | 设置手动提交事务set  autocommit=0 |
|     更新但不提交，没有commit      |              被阻塞               |
|             提交更新              |        阻塞解除，更新正常         |

注意，**行锁是建立在索引的基础上的**，如果你要查询的**这个字段没有加上索引**，**那么mysql就会默认锁住所有的行**。

### 按照思想划分的锁：

#### **乐观锁、悲观锁**

- **乐观锁(Optimistic Lock)**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。

乐观锁, 顾名思义，就是很乐观，**每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制**。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。

- **悲观锁(Pessimistic Lock)**：**假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作**。悲观锁，顾名思义，就是很悲观，**每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁**，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。

区别：（略~~~o(*￣︶￣*)o）

## **死锁（Deadlock Free）**

- **死锁产生：**

- - 死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。
  - 当事务试图以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时也可能会产生死锁。
  - 锁的行为和顺序和存储引擎相关。以同样的顺序执行语句，有些存储引擎会产生死锁有些不会——死锁有双重原因：真正的数据冲突；存储引擎的实现方式。
  - **检测死锁：**数据库系统实现了各种死锁检测和死锁超时的机制。InnoDB存储引擎能检测到死锁的循环依赖并立即返回一个错误。

  - **死锁恢复：****死锁发生以后，只有部分或完全回滚其中一个事务，才能打破死锁**，InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。所以事务型应用程序在设计时必须考虑如何处理死锁，多数情况下只需要重新执行因死锁回滚的事务即可。简言之：

- **通过innodblockwait_timeout（long timeout  TimeUnit unit）来设置超时时间，一直等待直到超时。**

- **发起死锁检测，发现死锁之后，主动回滚死锁中的事务，不需要其他事务继续**。

  **死锁影响性能：****死锁会影响性能而不是会产生严重错误**，因为InnoDB会自动检测死锁状况并回滚其中一个受影响的事务。在高并发系统上，当许多线程等待同一个锁时，死锁检测可能导致速度变慢。 有时当发生死锁时，禁用死锁检测（使用innodb_deadlock_detect配置选项）可能会更有效，这时可以依赖innodb_lock_wait_timeout设置进行事务回滚。
  
  ##### end~~~~:因事务并发引起的问题：（四种隔离级别，三种隔离，四大特性）打开钉钉，直播回放参考0318_spring09

#### 如何避免死锁以及优化锁性能：(https://zhuanlan.zhihu.com/p/29150809)
